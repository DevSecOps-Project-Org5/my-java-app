// Jenkinsfile 
pipeline { 
    // Agent definition. Use 'kubernetes' if you have the Kubernetes 
plugin for dynamic agents. 
    // For simplicity, 'any' assumes Docker and kubectl are available 
on the main Jenkins agent or a configured fixed agent. 
    agent any 
 
    environment { 
        // --- Configuration Variables --- 
        // Your Docker Hub username or private registry host 
        DOCKER_REGISTRY_HOST = "docker.io" // For Docker Hub 
        DOCKER_IMAGE_NAME = "your-docker-username/my-java-app" // 
IMPORTANT: Change 'your-docker-username' 
        // Jenkins Credentials ID for Docker Hub (Username with 
password) 
        // Set this up in Jenkins -> Manage Jenkins -> Manage 
Credentials -> Add Credentials (Kind: Username with password) 
        DOCKER_CREDENTIALS_ID = "docker-hub-credentials" 
 
        // Jenkins Credentials ID for Kubeconfig (Secret file 
credential pointing to your ~/.kube/config file) 
        // Set this up in Jenkins -> Manage Jenkins -> Manage 
Credentials -> Add Credentials (Kind: Secret file) 
        KUBECONFIG_CREDENTIALS_ID = "kubeconfig-file" 
 
        // Tag for the Docker image (using Jenkins build number for 
unique tags) 
        IMAGE_TAG = "${env.BUILD_NUMBER}" 
        # --- End Configuration Variables --- 
    } 
 
    stages { 
        stage('Checkout Source') { 
            steps { 
                script { 
                    echo "Checking out Git repository..." 
                    // Assumes your Jenkins job is configured to use 
Git SCM 
                    // For declarative pipeline, this often happens 
implicitly, 
                    // but it's good to be explicit for understanding. 
                    // If you're using a "Pipeline from SCM" job, this 
step is handled automatically. 
                    // For a Freestyle job configured as pipeline, you 
might need: 
                    // checkout scm 
                } 
            } 
        } 
 
        stage('Build Java Application') { 
            steps { 
                script { 
                    echo "Building Java application with Maven..." 
                    // -DskipTests: Unit tests should ideally run in a 
separate 'Test' stage 
                    // before building the artifact, but for a quick 
build, we skip them here. 
                    // A proper CI would have: mvn clean install 
                    sh 'mvn clean package -DskipTests' 
                    stash includes: 'target/*.jar', name: 'app-jar' 
                } 
            } 
            post { 
                failure { 
                    echo "Maven build failed!" 
                } 
            } 
        } 
 
        stage('Run Unit Tests') { 
            steps { 
                script { 
                    echo "Running Unit Tests..." 
                    // Make sure your pom.xml has the test 
dependencies 
                    sh 'mvn test' 
                    // Optional: Publish JUnit test results for 
Jenkins UI 
                    junit '**/target/surefire-reports/*.xml' 
                } 
            } 
            post { 
                failure { 
                    echo "Unit tests failed! Aborting pipeline." 
                    // Fail the build if tests fail 
                    currentBuild.result = 'FAILED' 
                } 
            } 
        } 
 
        stage('Build & Push Docker Image') { 
            steps { 
                script { 
                    echo "Building Docker image: 
${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}" 
                    
docker.withRegistry("https://${env.DOCKER_REGISTRY_HOST}", 
env.DOCKER_CREDENTIALS_ID) { 
                        def appImage = 
docker.build("${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}", "-f 
Dockerfile .") 
                        echo "Pushing Docker image: 
${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}" 
                        appImage.push() 
                        // Optional: Also push with 'latest' tag for 
convenience in development/testing 
                        appImage.push("latest") 
                    } 
                } 
            } 
            post { 
                failure { 
                    echo "Docker image build or push failed!" 
                } 
            } 
        } 
 
        stage('Deploy to Kubernetes') { 
            steps { 
                script { 
                    echo "Deploying to Kubernetes..." 
                    // Using withKubeConfig context for secure kubectl 
execution 
                    withKubeConfig(credentialsId: 
env.KUBECONFIG_CREDENTIALS_ID) { 
                        // Dynamically update the image tag in the 
deployment manifest 
                        // This is a simple sed. For production, 
consider `envsubst`, Helm, or Kustomize. 
                        def deploymentFile = 
"kubernetes/deployment.yaml" 
                        def serviceFile = "kubernetes/service.yaml" 
                        def imageToDeploy = 
"${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}" 
 
                        echo "Updating Kubernetes deployment image to: 
${imageToDeploy}" 
                        sh "sed -i 
's|REPLACE_IMAGE_WITH_DYNAMIC_TAG|${imageToDeploy}|g' 
${deploymentFile}" 
 
                        echo "Applying Kubernetes Deployment and 
Service..." 
                        sh "kubectl apply -f ${deploymentFile}" 
                        sh "kubectl apply -f ${serviceFile}" 
 
                        echo "Waiting for deployment rollout to 
complete..." 
                        sh "kubectl rollout status 
deployment/my-java-app-deployment --timeout=300s" 
                        echo "Deployment successful!" 
                    } 
                } 
            } 
            post { 
                failure { 
                    echo "Kubernetes deployment failed!" 
                } 
            } 
        } 
 
        stage('Post-Deployment Verification (Optional)') { 
            steps { 
                script { 
                    echo "Running post-deployment verification..." 
                    // Get the IP of the LoadBalancer service 
                    def serviceIp = sh(returnStdout: true, script: 
"kubectl get service my-java-app-service -o 
jsonpath='{.status.loadBalancer.ingress[0].ip}'").trim() 
                    if (!serviceIp) { 
                        serviceIp = sh(returnStdout: true, script: 
"kubectl get service my-java-app-service -o 
jsonpath='{.status.loadBalancer.ingress[0].hostname}'").trim() 
                    } 
 
                    if (serviceIp) { 
                        echo "Service IP/Hostname: ${serviceIp}" 
                        // Simple curl to the health endpoint 
                        sh "curl -f http://${serviceIp}/health" 
                        echo "Health check passed!" 
                    } else { 
                        echo "Could not get service IP/Hostname. 
Manual verification may be needed." 
                    } 
                } 
            } 
            post { 
                failure { 
                    echo "Post-deployment verification failed!" 
                } 
            } 
        } 
    } 
 
    post { 
        always { 
            cleanWs() // Clean up workspace 
        } 
        success { 
            echo "Pipeline finished successfully!" 
            // Add Slack/Email notifications here 
            // slackSend channel: '#devops-alerts', message: "SUCCESS: 
${env.JOB_NAME} Build #${env.BUILD_NUMBER} deployed successfully." 
        } 
        failure { 
            echo "Pipeline failed!" 
            // Add Slack/Email notifications here 
            // slackSend channel: '#devops-alerts', message: "FAILURE: 
${env.JOB_NAME} Build #${env.BUILD_NUMBER} failed. See 
${env.BUILD_URL}" 
        } 
    } 
}